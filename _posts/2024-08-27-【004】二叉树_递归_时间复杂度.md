---
tag: 随记
---

> 今天刷到有关二叉树的LeetCode相关算法，大部分都涉及到了递归，故查阅王争哥<<数据结构与算法之美>>的相关章节，在这里记录一下个人感受。

## 时间复杂度

复杂度计算排除测试环境、数据规模等相关限制，常见的有O(1)、O(logn)、O(n)、O(nlogn) 四种情况

### O(nlogn)

+ 归并排序(merge sort)

  ```c
  //分而治之
  //分治是一种解决问题的处理思想，递归是一种编程技巧
  //递推公式：merge_sort(p, r) = merge(merge_sort(p, q) + merge_sort(q+1, r));
  //终止条件：p > r
  void merge(int* arr, int p, int r)
  {
      int q = (r-p)/2;
      int i = p;
      int j = q+1;
      int k = 0;
      int *tmp = (int *)malloc(sizeof(int)*(r-p+1));
  
      while(i <= q && j <= r)
      {
          if(arr[i] <= arr[j])//稳定排序
              tmp[k++] = arr[i++];
          else
              tmp[k++] = arr[j++];
      }
      
      int start = i;
      int end = q;
      if(j <= r)
          start = j;
      	end = r;
      
      while(start <= end)
          tmp[k++] = arr[start++];
      
      for(i = 0; i <= r-p; i++)
      {
          arr[p+i] = tmp[i++];
      }
      free(tmp);
  }
  
  void merge_sort_c(int* arr, int p, int r)
  {
      if(p > r)
          return;
      int q = (p + r)/2;
      merge_sort_c(arr, p, q);
      merge_sort_c(arr, q+1, r);
      merge(arr, p, r);
  }
  
  void merge_sort(int* arr, int len)
  {
      merge_sort_c(arr, 0, len-1);
  }
  ```

+ 快排

  ```c
  //递推公式：quick_sort(p,r) = quick_sort(p,q-1) + quick_sort(q+1,r)
  //终止条件：p >= r
  int partition(int* arr, int p, int r)
  {
      int pivot = arr[r];
      int i = p;
      for(int j = p; j < r; j++)
      {
          if(arr[j] < pivot)
          {
              int tmp = arr[i];
              arr[i] = arr[j];
              arr[j] = tmp;
              ++i;
          }
      }
      int tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
      return i;
  }
  
  void quick_sort_c(int* arr, int p, int r)
  {
      if(p >= r)
          return;
      int q = partition(arr, p, r);
      quick_sort_c(arr, p, q-1);
      quick_sort_c(arr, q+1, r);
  }
  
  void quick_sort(int* arr, int len)
  {
      quick_sort_c(arr, 0, len-1);
  }
  ```

  

+ 平衡树(自顶向下)--<u>案例在最后</u>

## ”递“ 与 “归”

递归我认为是算法中最最最最难的部分，实在难以捉摸，好在有一定的规则：

**1. 一个问题的解可以分解为几个子问题的解**

**2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样**

**3. 存在递归终止条件**

若出现以上情况，大概率可以使用递归来解决。

<span style="color:blue; font-size:50px">写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</span>

> **编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤**。

*WARNING:*

1. ***递归代码要警惕堆栈溢出!!!***

2. ***递归代码要警惕重复计算!!!***



#### 递归代码改写为非递归代码

### 二叉树代码实战

1. 前、中、后序遍历(递归)

```c
//时间复杂度O(n)
void preOrder(Node* root) {
  if (root == null) return;
  print root // 此处为伪代码，表示打印 root 节点
  preOrder(root->left);
  preOrder(root->right);
}
 
void inOrder(Node* root) {
  if (root == null) return;
  inOrder(root->left);
  print root // 此处为伪代码，表示打印 root 节点
  inOrder(root->right);
}
 
void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  print root // 此处为伪代码，表示打印 root 节点
}
```

2. 按层遍历

```c
struct BTNode
{
	char val;
	struct BTNode* pLchild;
	struct BTNode* pRchild;
};

struct BTNode* CreateBTtree(void)
{
	struct BTNode* pA = (struct BTNode*)malloc(sizeof(struct BTNode));
	struct BTNode* pB = (struct BTNode*)malloc(sizeof(struct BTNode));
	struct BTNode* pC = (struct BTNode*)malloc(sizeof(struct BTNode));
	struct BTNode* pD = (struct BTNode*)malloc(sizeof(struct BTNode));
	struct BTNode* pE = (struct BTNode*)malloc(sizeof(struct BTNode));

	pA->val = 'A';
	pB->val = 'B';
	pC->val = 'C';
	pD->val = 'D';
	pE->val = 'E';

	pA->pLchild = pB;
	pA->pRchild = pC;
	pB->pLchild = pB->pRchild = NULL;
	pC->pLchild = pD;
	pC->pRchild = NULL;
	pD->pLchild = NULL;
	pD->pRchild = pE;
	pE->pLchild = pE->pRchild = NULL;

	return pA;
}
int front = 0, rear = 0;
struct BTNode* arr[20] = {0};
struct BTNode* DeQueue(struct BTNode* arr)
{
    return arr[front++];
}

void EnQueue(struct BTNode* arr, struct BTNode* Node)
{
    arr[rear++] = Node;
}

void displayNode(struct BTNode* Node)
{
    printf("%c", Node->val);
}

int main()
{
    struct BTNode* pHead = CreateBTtree();
    EnQueue(arr, pHead);
    while(front < rear)
    {
        struct BTNode* tmp = DeQueue(arr);
        displayNode(tmp);
        if(tmp->pLchild != NULL)
            EnQueue(arr, tmp->pLchild);
        if(tmp->pRchild != NULL)
            EnQueue(arr, tmp->pRchild);        
    }
    return 0;
}
```

3.求二叉树深度(递归)

```c
int maxDepth(struct BTNode* pNode)
{
    if(pNode == NULL)
        return 0;
    int left_depth = maxDepth(pNode->pLchild);
    int right_depth = maxDepth(pNode->pRchild);
    return left_depth > right_depth ? left_depth+1 : right_depth+1;
}
```

4.判断二叉树是否相等(递归)

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
bool isSameTree(struct TreeNode* p, struct TreeNode* q) {
    if(p == NULL && q == NULL)
        return true;
    else if(p == NULL || q == NULL)
        return false;
    else if(p->val != q->val)
        return false;
    else
        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}
```

5.判断是否为平衡二叉树

```c
//方法1 自顶向下
bool isBalanced(struct TreeNode* root) {
    if(root == NULL)
        return true;
    if(abs(maxDepth(root->left) - maxDepth(root->right)) > 1)
        return false;
    return isBalanced(root->left) && isBalanced(root->right);
}
```

> 时间复杂度：O(n2)，其中 n 是二叉树中的节点个数。最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O(n)。对于节点 p，如果它的高度是 d，则 height(p) 最多会被调用 d 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足 O(h)=O(logn)，因为 d≤h，所以总时间复杂度为 O(nlogn)。对于最坏的情况，二叉树形成链式结构，高度为 O(n)，此时总时间复杂度为 O(n2)。
>
> 空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。
>
> 作者：力扣官方题解
> 链接：https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/solutions/832191/ping-heng-er-cha-shu-by-leetcode-solutio-6r1g/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```c
//自底向上
int height(struct TreeNode* root)
{
    if(root == NULL)
        return 0;
    int leftHeight = height(root->left);
    int rightHeight = height(root->right);
    if(leftHeight == -1 || rightHeight == -1 || fabs(leftHeight - rightHeight) > 1)
        return -1;
    else
        return fmax(leftHeight, rightHeight) + 1;
}
bool isBalanced(struct TreeNode* root)
{
    return height(root) >= 0;
}
```

> 时间复杂度：O(n)，其中 n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O(n)。
>
> 空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。
>
> 作者：力扣官方题解
> 链接：https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/solutions/832191/ping-heng-er-cha-shu-by-leetcode-solutio-6r1g/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。